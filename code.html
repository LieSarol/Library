<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Blob HTML Editor â€” Top/Bottom + 1.5x Scroll</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Just to make selection handles visible on dark bg */
    ::selection { background: #a3e63540; }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-[150vh] flex flex-col">
  <!-- Header -->
  <header class="p-3 md:p-4 border-b border-gray-800 sticky top-0 bg-gray-900/80 backdrop-blur z-10">
    <h1 class="text-lg md:text-xl font-semibold">Blob HTML Editor</h1>
    <p class="text-xs md:text-sm text-gray-400">Top & bottom layout â€¢ Logs: console, fetch, XHR, errors â€¢ Page scrolls 1.5Ã—</p>
  </header>

  <!-- Controls -->
  <div class="px-3 md:px-4 py-2 flex gap-2 items-center">
    <button id="runBtn" class="px-3 py-1.5 rounded-xl bg-emerald-600 hover:bg-emerald-500 transition">
      Run â–¶
    </button>
    <button id="clearLogsBtn" class="px-3 py-1.5 rounded-xl bg-gray-700 hover:bg-gray-600 transition">
      Clear logs
    </button>
    <span class="text-xs text-gray-400">Editor â†‘ â€¢ Preview â†“</span>
  </div>

  <!-- Editor (TOP) -->
  <section class="px-3 md:px-4 pb-3">
    <textarea id="editor"
      class="w-full h-[45vh] p-3 md:p-4 font-mono text-sm md:text-base bg-gray-800 text-green-300 rounded-xl outline-none focus:ring-2 ring-emerald-600"
      spellcheck="false" placeholder="Type HTML hereâ€¦"></textarea>
  </section>

  <!-- Preview (BOTTOM) -->
  <section class="px-3 md:px-4 pb-3">
    <iframe id="preview"
      class="w-full h-[45vh] bg-white rounded-xl border border-gray-800"
      sandbox="allow-scripts allow-forms">
    </iframe>
  </section>

  <!-- Logs -->
  <section class="px-3 md:px-4 pb-6">
    <div class="text-xs text-gray-400 mb-1">Logs from preview</div>
    <div id="logs" class="h-48 bg-black/70 rounded-xl overflow-y-auto p-2 font-mono text-xs"></div>
  </section>

  <script>
    const editor = document.getElementById('editor');
    const preview = document.getElementById('preview');
    const logs = document.getElementById('logs');
    const runBtn = document.getElementById('runBtn');
    const clearLogsBtn = document.getElementById('clearLogsBtn');

    let currentBlobURL = null;
    const MAX_LOGS = 500;

    function logMessage(kind, ...parts) {
      const line = document.createElement('div');
      const time = new Date().toLocaleTimeString();
      line.textContent = `[${time}] [${kind}] ${parts.map(String).join(' ')}`;
      logs.appendChild(line);
      // Trim log length
      while (logs.childNodes.length > MAX_LOGS) logs.removeChild(logs.firstChild);
      logs.scrollTop = logs.scrollHeight;
    }

    function safeStringify(value) {
      try { return typeof value === 'string' ? value : JSON.stringify(value); }
      catch { return String(value); }
    }

    function buildInstrumentedHTML(userHTML) {
      // Script injected BEFORE user HTML to hook console/fetch/XHR/errors
      return `
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Preview</title>
<style>html,body{margin:0;padding:0}</style>
</head>
<body>
<script>
(function () {
  function send(type, payload) {
    try { parent.postMessage({ __from_preview: true, type, payload }, '*'); }
    catch (e) {}
  }

  // Console hooks
  ['log','warn','error','info'].forEach(fn => {
    const orig = console[fn];
    console[fn] = function(...args){
      try {
        const msg = args.map(a => {
          try { return typeof a === 'string' ? a : JSON.stringify(a); }
          catch { return String(a); }
        }).join(' ');
        send('console:' + fn, msg);
      } finally {
        try { orig.apply(console, args); } catch(e){}
      }
    };
  });

  // fetch hook
  const origFetch = window.fetch;
  window.fetch = function(resource, init){
    try {
      const info = (typeof resource === 'string') ? resource : (resource && resource.url);
      send('fetch', String(info || 'unknown'));
    } catch(e){}
    return origFetch.apply(this, arguments).then(r => {
      try { send('fetch:done', (r && r.url) + ' ' + r.status); } catch(e){}
      return r;
    }).catch(err => {
      try { send('fetch:error', String(err)); } catch(e){}
      throw err;
    });
  };

  // XHR hook
  (function(){
    const OrigXHR = XMLHttpRequest;
    function WrappedXHR(){
      const xhr = new OrigXHR();
      let _method = '', _url = '';
      const origOpen = xhr.open;
      xhr.open = function(method, url){
        _method = method; _url = url;
        try { send('xhr:open', method + ' ' + url); } catch(e){}
        return origOpen.apply(xhr, arguments);
      };
      const origSend = xhr.send;
      xhr.send = function(body){
        try { send('xhr:send', _method + ' ' + _url); } catch(e){}
        xhr.addEventListener('load', function(){
          try { send('xhr:done', _method + ' ' + _url + ' ' + xhr.status); } catch(e){}
        });
        xhr.addEventListener('error', function(){
          try { send('xhr:error', _method + ' ' + _url); } catch(e){}
        });
        return origSend.apply(xhr, arguments);
      };
      return xhr;
    }
    WrappedXHR.prototype = OrigXHR.prototype;
    window.XMLHttpRequest = WrappedXHR;
  })();

  // Error handlers
  window.addEventListener('error', function(e){
    try { send('error', (e.message || 'error') + ' @ ' + (e.filename || '') + ':' + (e.lineno || '')); } catch(_){}
  });
  window.addEventListener('unhandledrejection', function(e){
    try { send('unhandledrejection', String(e.reason)); } catch(_){}
  });

})();
<\/script>

${userHTML}

</body>
</html>`;
    }

    function updatePreview() {
      const instrumented = buildInstrumentedHTML(editor.value);
      const blob = new Blob([instrumented], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      if (currentBlobURL) URL.revokeObjectURL(currentBlobURL);
      currentBlobURL = url;
      preview.src = url;
      logMessage('system', 'Preview updated with new Blob URL');
    }

    // Debounce typing to avoid spamming blob updates
    let t;
    editor.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(updatePreview, 250);
    });

    runBtn.addEventListener('click', updatePreview);
    clearLogsBtn.addEventListener('click', () => { logs.textContent = ''; });

    // Receive messages from preview
    window.addEventListener('message', (e) => {
      const data = e.data || {};
      if (!data.__from_preview) return;
      const { type, payload } = data;
      logMessage(type, payload);
    });

    // Default example
    editor.value = `<!-- Try editing me! -->
<h1 style="font-family: system-ui;">Hello from the preview ðŸ‘‹</h1>
<p>This preview is powered by a Blob URL. We hook console, fetch, XHR, and errors â€” and report them back to the editor.</p>

<button id="go">Fetch a sample todo</button>
<script>
document.getElementById('go').addEventListener('click', async () => {
  console.log('Button clicked, about to fetchâ€¦');
  const r = await fetch('https://jsonplaceholder.typicode.com/todos/1');
  const j = await r.json();
  console.info('Got JSON', j);
});

// Fire an XHR as well (just to demo)
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/2');
xhr.onload = () => console.log('XHR ok:', xhr.status);
xhr.onerror = () => console.error('XHR oops');
xhr.send();

// Throw an error for the drama
setTimeout(() => { throw new Error('whoops from inside preview'); }, 1200);
<\/script>`;
    // Initial render
    updatePreview();

    // Cleanup blob on unload
    window.addEventListener('beforeunload', () => {
      if (currentBlobURL) URL.revokeObjectURL(currentBlobURL);
    });
  </script>
</body>
</html>
